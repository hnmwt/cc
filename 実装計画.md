# 外観検査アプリケーション 実装計画書

## ドキュメント情報
- **プロジェクト名**: 外観検査システム
- **バージョン**: 1.0
- **作成日**: 2025-11-16
- **ステータス**: Draft

---

## 1. アーキテクチャ設計

### 1.1 システムアーキテクチャ

```
┌─────────────────────────────────────────────────────────────┐
│                        UI Layer (Qt/OpenCV)                  │
│  ┌──────────────┬──────────────┬──────────────────────────┐ │
│  │ Main Window  │ Filter Panel │ Result Display           │ │
│  └──────────────┴──────────────┴──────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                    Application Layer                         │
│  ┌──────────────┬──────────────┬──────────────────────────┐ │
│  │ Inspection   │ Camera       │ Data Manager             │ │
│  │ Controller   │ Controller   │                          │ │
│  └──────────────┴──────────────┴──────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                     Processing Layer                         │
│  ┌──────────────────────────────────────────────────────┐   │
│  │            Image Processing Pipeline                  │   │
│  │  ┌──────────┬──────────┬──────────┬──────────────┐  │   │
│  │  │ Filter 1 │ Filter 2 │ Filter N │ AI Enhancer  │  │   │
│  │  └──────────┴──────────┴──────────┴──────────────┘  │   │
│  └──────────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │            Defect Detection Engine                    │   │
│  │  ┌──────────┬──────────┬──────────┬──────────────┐  │   │
│  │  │Template  │ Feature  │Statistical│ AI Detector  │  │   │
│  │  │Matching  │ Based    │ Method    │              │  │   │
│  │  └──────────┴──────────┴──────────┴──────────────┘  │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                       Core Layer                             │
│  ┌──────────────┬──────────────┬──────────────────────────┐ │
│  │ Image I/O    │ Plugin       │ Configuration            │ │
│  │              │ Manager      │ Manager                  │ │
│  └──────────────┴──────────────┴──────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                      Data Layer                              │
│  ┌──────────────┬──────────────┬──────────────────────────┐ │
│  │ SQLite DB    │ File Storage │ Config Files (JSON)      │ │
│  └──────────────┴──────────────┴──────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 設計原則

#### 1.2.1 プラグインアーキテクチャ
- **基底クラス方式**: すべての画像処理とアルゴリズムは共通インターフェースを実装
- **動的登録**: ファクトリパターンで実行時に登録・取得
- **疎結合**: アルゴリズム間の依存を最小化

#### 1.2.2 パイプラインパターン
- 画像処理を連鎖的に適用
- 各ステージの入出力は `cv::Mat` で統一
- ステージの順序変更や追加が容易

#### 1.2.3 MVC/MVVMパターン
- Model: データ処理・ビジネスロジック
- View: UI表示
- Controller/ViewModel: Model と View の仲介

---

## 2. ディレクトリ構造

```
inspection_app/
├── CMakeLists.txt                  # ビルド設定
├── README.md                       # プロジェクト説明
├── CLAUDE.md                       # AI指示書
├── project.md                      # プロジェクト仕様書
├── 要件.md                         # 要件定義書
├── 実装計画.md                     # 本ドキュメント
│
├── include/                        # ヘッダーファイル
│   ├── core/                       # コア機能
│   │   ├── image_io.hpp           # 画像入出力
│   │   ├── plugin_manager.hpp    # プラグイン管理
│   │   └── config_manager.hpp    # 設定管理
│   │
│   ├── processing/                 # 画像処理
│   │   ├── filter_base.hpp        # フィルタ基底クラス
│   │   ├── pipeline.hpp           # パイプライン
│   │   ├── filters/               # 各種フィルタ
│   │   │   ├── grayscale_filter.hpp
│   │   │   ├── gaussian_filter.hpp
│   │   │   ├── median_filter.hpp
│   │   │   ├── threshold_filter.hpp
│   │   │   ├── edge_detector.hpp
│   │   │   └── morphology_filter.hpp
│   │   └── ai_enhancer.hpp        # AI高画質化
│   │
│   ├── detection/                  # 欠陥検出
│   │   ├── detector_base.hpp      # 検出器基底クラス
│   │   ├── detectors/
│   │   │   ├── template_matcher.hpp
│   │   │   ├── feature_detector.hpp
│   │   │   ├── statistical_detector.hpp
│   │   │   └── ai_detector.hpp    # AI検出器
│   │   └── defect.hpp             # 欠陥データ構造
│   │
│   ├── app/                        # アプリケーション層
│   │   ├── inspection_controller.hpp
│   │   ├── camera_controller.hpp
│   │   └── data_manager.hpp
│   │
│   ├── ui/                         # UI
│   │   ├── main_window.hpp
│   │   ├── filter_panel.hpp
│   │   ├── result_display.hpp
│   │   └── settings_dialog.hpp
│   │
│   └── utils/                      # ユーティリティ
│       ├── logger.hpp
│       ├── timer.hpp
│       └── common.hpp
│
├── src/                            # ソースファイル
│   ├── core/
│   │   ├── image_io.cpp
│   │   ├── plugin_manager.cpp
│   │   └── config_manager.cpp
│   │
│   ├── processing/
│   │   ├── pipeline.cpp
│   │   ├── filters/
│   │   │   ├── grayscale_filter.cpp
│   │   │   ├── gaussian_filter.cpp
│   │   │   ├── median_filter.cpp
│   │   │   ├── threshold_filter.cpp
│   │   │   ├── edge_detector.cpp
│   │   │   └── morphology_filter.cpp
│   │   └── ai_enhancer.cpp
│   │
│   ├── detection/
│   │   ├── detectors/
│   │   │   ├── template_matcher.cpp
│   │   │   ├── feature_detector.cpp
│   │   │   ├── statistical_detector.cpp
│   │   │   └── ai_detector.cpp
│   │   └── defect.cpp
│   │
│   ├── app/
│   │   ├── inspection_controller.cpp
│   │   ├── camera_controller.cpp
│   │   └── data_manager.cpp
│   │
│   ├── ui/
│   │   ├── main_window.cpp
│   │   ├── filter_panel.cpp
│   │   ├── result_display.cpp
│   │   └── settings_dialog.cpp
│   │
│   ├── utils/
│   │   ├── logger.cpp
│   │   └── timer.cpp
│   │
│   └── main.cpp                    # エントリーポイント
│
├── tests/                          # テストコード
│   ├── unit/
│   │   ├── test_filters.cpp
│   │   ├── test_detectors.cpp
│   │   └── test_pipeline.cpp
│   └── integration/
│       └── test_inspection.cpp
│
├── config/                         # 設定ファイル
│   ├── default_config.json        # デフォルト設定
│   ├── filters.json               # フィルタ設定
│   └── presets/                   # プリセット
│       ├── preset1.json
│       └── preset2.json
│
├── data/                           # データディレクトリ
│   ├── reference/                 # 良品画像
│   ├── test_images/               # テスト画像
│   └── models/                    # AIモデル
│       ├── enhancer/
│       └── detector/
│
├── docs/                           # ドキュメント
│   ├── api/                       # API ドキュメント
│   ├── user_guide.md              # ユーザーガイド
│   └── plugin_development.md      # プラグイン開発ガイド
│
├── scripts/                        # ビルド・ユーティリティスクリプト
│   ├── build.sh
│   └── run_tests.sh
│
└── third_party/                    # サードパーティライブラリ
    └── README.md
```

---

## 3. クラス設計

### 3.1 Core Layer

#### 3.1.1 ImageIO
```cpp
class ImageIO {
public:
    static cv::Mat loadImage(const std::string& path);
    static bool saveImage(const std::string& path, const cv::Mat& image);
    static std::vector<cv::Mat> loadBatch(const std::vector<std::string>& paths);
    static std::vector<std::string> getSupportedFormats();
};
```

#### 3.1.2 PluginManager
```cpp
class PluginManager {
public:
    static PluginManager& getInstance();

    template<typename T>
    void registerPlugin(const std::string& name, std::function<std::unique_ptr<T>()> creator);

    template<typename T>
    std::unique_ptr<T> createPlugin(const std::string& name);

    template<typename T>
    std::vector<std::string> getPluginNames();

private:
    PluginManager() = default;
    // Registry maps for different plugin types
};
```

#### 3.1.3 ConfigManager
```cpp
class ConfigManager {
public:
    static ConfigManager& getInstance();

    void loadConfig(const std::string& path);
    void saveConfig(const std::string& path);

    template<typename T>
    T getValue(const std::string& key, const T& defaultValue);

    template<typename T>
    void setValue(const std::string& key, const T& value);

private:
    nlohmann::json config_;
};
```

### 3.2 Processing Layer

#### 3.2.1 FilterBase (抽象基底クラス)
```cpp
class FilterBase {
public:
    virtual ~FilterBase() = default;

    virtual cv::Mat process(const cv::Mat& input) = 0;
    virtual std::string getName() const = 0;
    virtual std::map<std::string, ParamInfo> getParameters() const = 0;
    virtual void setParameter(const std::string& name, const Variant& value) = 0;
    virtual Variant getParameter(const std::string& name) const = 0;

    bool isEnabled() const { return enabled_; }
    void setEnabled(bool enabled) { enabled_ = enabled; }

protected:
    bool enabled_ = true;
};
```

#### 3.2.2 Pipeline
```cpp
class Pipeline {
public:
    void addFilter(std::unique_ptr<FilterBase> filter);
    void insertFilter(size_t index, std::unique_ptr<FilterBase> filter);
    void removeFilter(size_t index);
    void moveFilter(size_t from, size_t to);
    void clearFilters();

    cv::Mat process(const cv::Mat& input);
    std::vector<cv::Mat> processWithIntermediates(const cv::Mat& input);

    size_t getFilterCount() const;
    FilterBase* getFilter(size_t index);

    void savePreset(const std::string& path);
    void loadPreset(const std::string& path);

private:
    std::vector<std::unique_ptr<FilterBase>> filters_;
};
```

#### 3.2.3 具体的なフィルタ例
```cpp
class GrayscaleFilter : public FilterBase {
public:
    cv::Mat process(const cv::Mat& input) override;
    std::string getName() const override { return "Grayscale"; }
    std::map<std::string, ParamInfo> getParameters() const override;
    void setParameter(const std::string& name, const Variant& value) override;
    Variant getParameter(const std::string& name) const override;
};

class GaussianFilter : public FilterBase {
public:
    cv::Mat process(const cv::Mat& input) override;
    std::string getName() const override { return "Gaussian Blur"; }
    // ... parameters: kernelSize, sigma

private:
    int kernelSize_ = 5;
    double sigma_ = 1.0;
};

class ThresholdFilter : public FilterBase {
public:
    enum class Method { BINARY, OTSU, ADAPTIVE };

    cv::Mat process(const cv::Mat& input) override;
    // ... parameters: threshold, method, maxValue

private:
    int threshold_ = 128;
    Method method_ = Method::BINARY;
    int maxValue_ = 255;
};
```

### 3.3 Detection Layer

#### 3.3.1 Defect (欠陥データ構造)
```cpp
enum class DefectType {
    SCRATCH,      // 傷
    STAIN,        // 汚れ
    DISCOLORATION,// 変色
    DEFORMATION,  // 形状不良
    UNKNOWN
};

struct Defect {
    DefectType type;
    cv::Rect boundingBox;
    std::vector<cv::Point> contour;
    double confidence;
    std::map<std::string, double> features;
};
```

#### 3.3.2 DetectorBase (抽象基底クラス)
```cpp
class DetectorBase {
public:
    virtual ~DetectorBase() = default;

    virtual std::vector<Defect> detect(const cv::Mat& image) = 0;
    virtual std::string getName() const = 0;
    virtual void configure(const nlohmann::json& config) = 0;

    virtual double getSensitivity() const { return sensitivity_; }
    virtual void setSensitivity(double value) { sensitivity_ = value; }

protected:
    double sensitivity_ = 0.7;
};
```

#### 3.3.3 具体的な検出器例
```cpp
class TemplateMatcher : public DetectorBase {
public:
    std::vector<Defect> detect(const cv::Mat& image) override;
    void setReferenceImage(const cv::Mat& reference);
    void setMatchingThreshold(double threshold);

private:
    cv::Mat referenceImage_;
    double matchingThreshold_ = 0.8;
};

class AIDetector : public DetectorBase {
public:
    std::vector<Defect> detect(const cv::Mat& image) override;
    void loadModel(const std::string& modelPath);
    void setModelType(const std::string& type);

private:
    // AI model wrapper (ONNX Runtime, TensorFlow Lite, etc.)
    std::unique_ptr<AIModelWrapper> model_;
};
```

### 3.4 Application Layer

#### 3.4.1 InspectionController
```cpp
class InspectionController {
public:
    struct InspectionResult {
        bool isOK;
        std::vector<Defect> defects;
        cv::Mat processedImage;
        double processingTime;
        std::map<std::string, double> statistics;
    };

    InspectionResult inspect(const cv::Mat& image);
    void setPipeline(std::unique_ptr<Pipeline> pipeline);
    void addDetector(std::unique_ptr<DetectorBase> detector);
    void setReferenceImage(const cv::Mat& reference);

private:
    std::unique_ptr<Pipeline> pipeline_;
    std::vector<std::unique_ptr<DetectorBase>> detectors_;
    cv::Mat referenceImage_;
};
```

#### 3.4.2 CameraController
```cpp
class CameraController {
public:
    bool openCamera(int deviceId);
    void closeCamera();
    bool isOpened() const;

    cv::Mat captureFrame();
    void startContinuousCapture(std::function<void(cv::Mat)> callback);
    void stopContinuousCapture();

    void setResolution(int width, int height);
    void setFPS(int fps);
    void setExposure(double value);
    void setGain(double value);

private:
    cv::VideoCapture capture_;
    std::thread captureThread_;
    std::atomic<bool> capturing_{false};
};
```

#### 3.4.3 DataManager
```cpp
class DataManager {
public:
    struct InspectionRecord {
        int id;
        std::string timestamp;
        std::string imagePath;
        bool result;
        std::vector<Defect> defects;
        nlohmann::json metadata;
    };

    void initialize(const std::string& dbPath);
    void saveInspectionResult(const InspectionRecord& record);
    std::vector<InspectionRecord> getHistory(const std::string& fromDate, const std::string& toDate);
    void exportToCSV(const std::string& path, const std::vector<InspectionRecord>& records);

    struct Statistics {
        int totalInspections;
        int okCount;
        int ngCount;
        double defectRate;
        std::map<DefectType, int> defectTypeDistribution;
    };

    Statistics getStatistics(const std::string& fromDate, const std::string& toDate);

private:
    std::unique_ptr<SQLite::Database> db_;
};
```

### 3.5 UI Layer

#### 3.5.1 MainWindow
```cpp
class MainWindow : public QMainWindow {
    Q_OBJECT

public:
    MainWindow(QWidget* parent = nullptr);
    ~MainWindow();

private slots:
    void onLoadImage();
    void onOpenCamera();
    void onInspect();
    void onSaveResult();
    void onFilterParameterChanged(const QString& filterName, const QString& paramName, const QVariant& value);

private:
    void setupUI();
    void updateDisplay();

    std::unique_ptr<InspectionController> controller_;
    FilterPanel* filterPanel_;
    ResultDisplay* resultDisplay_;
    QLabel* imageLabel_;
};
```

---

## 4. 実装フェーズ詳細

### Phase 1: 基礎インフラ構築（2-3週間）

#### タスク 1.1: プロジェクト環境構築
- [ ] CMakeLists.txt 作成
- [ ] ディレクトリ構造構築
- [ ] OpenCV 4.x インストール・設定
- [ ] ビルドシステム動作確認
- [ ] Git リポジトリ初期化

#### タスク 1.2: Core Layer 実装
- [ ] ImageIO クラス実装
  - [ ] 画像読み込み (JPEG, PNG, BMP, TIFF)
  - [ ] 画像保存
  - [ ] バッチ読み込み
  - [ ] エラーハンドリング
- [ ] ConfigManager クラス実装
  - [ ] JSON パーサー統合 (nlohmann/json)
  - [ ] 設定読み込み・保存
  - [ ] デフォルト設定
- [ ] Logger ユーティリティ実装
  - [ ] ログレベル (DEBUG, INFO, WARN, ERROR)
  - [ ] ファイル出力
  - [ ] コンソール出力

#### タスク 1.3: 基本的な画像処理実装
- [ ] FilterBase 抽象クラス定義
- [ ] Pipeline クラス実装
- [ ] 基本フィルタ実装
  - [ ] GrayscaleFilter
  - [ ] GaussianFilter
  - [ ] ThresholdFilter (Binary)

#### タスク 1.4: 簡易UI作成（OpenCV HighGUI）
- [ ] ウィンドウ表示
- [ ] 画像読み込みボタン
- [ ] 処理結果表示
- [ ] トラックバーでパラメータ調整

#### タスク 1.5: 統合テスト
- [ ] サンプル画像での動作確認
- [ ] フィルタパイプライン動作確認

**成果物:**
- ビルド可能なプロジェクト
- 画像読み込み→フィルタ適用→表示の基本フロー
- 設定ファイルの読み書き

---

### Phase 2: 検出機能実装（3-4週間）

#### タスク 2.1: Detection Layer 基盤
- [ ] Defect データ構造定義
- [ ] DetectorBase 抽象クラス定義
- [ ] 検出結果の可視化機能

#### タスク 2.2: テンプレートマッチング実装
- [ ] TemplateMatcher クラス実装
- [ ] 良品画像登録機能
- [ ] 差分検出アルゴリズム
- [ ] 閾値調整機能
- [ ] マッチング精度評価

#### タスク 2.3: 特徴量ベース検出実装
- [ ] FeatureDetector クラス実装
- [ ] 輪郭検出 (cv::findContours)
- [ ] 特徴量計算
  - [ ] 面積
  - [ ] 周囲長
  - [ ] 円形度
  - [ ] アスペクト比
- [ ] 異常値判定ロジック

#### タスク 2.4: 統計的検出実装
- [ ] StatisticalDetector クラス実装
- [ ] ヒストグラム解析
- [ ] 標準偏差による異常検出

#### タスク 2.5: 追加フィルタ実装
- [ ] MedianFilter
- [ ] EdgeDetector (Canny, Sobel)
- [ ] MorphologyFilter (膨張、収縮、オープニング、クロージング)
- [ ] AdaptiveThresholdFilter

#### タスク 2.6: InspectionController 実装
- [ ] パイプライン統合
- [ ] 検出器統合
- [ ] 結果集計ロジック
- [ ] 処理時間計測

#### タスク 2.7: テストとチューニング
- [ ] 各検出器の単体テスト
- [ ] 精度評価（感度・特異度）
- [ ] パラメータチューニング

**成果物:**
- 複数の検出アルゴリズム
- 検出精度90%以上達成
- テストデータセットでの検証結果

---

### Phase 3: プラグインシステム実装（2-3週間）

#### タスク 3.1: PluginManager 実装
- [ ] ファクトリパターンによる登録システム
- [ ] テンプレートベースのプラグイン管理
- [ ] プラグインメタデータ管理

#### タスク 3.2: プラグインインターフェース整備
- [ ] FilterBase の拡張
  - [ ] パラメータ定義システム
  - [ ] バリデーション機能
- [ ] DetectorBase の拡張

#### タスク 3.3: プラグイン設定システム
- [ ] JSON による設定外部化
- [ ] 設定ファイルからのプラグイン読み込み
- [ ] プリセット機能

#### タスク 3.4: リアルタイム調整UI (FilterPanel)
- [ ] パラメータごとのスライダー生成
- [ ] リアルタイムプレビュー
- [ ] Undo/Redo 機能
- [ ] プリセット保存/読み込み

#### タスク 3.5: ドキュメント作成
- [ ] プラグイン開発ガイド
- [ ] サンプルプラグイン実装
- [ ] API ドキュメント

**成果物:**
- 拡張可能なプラグインシステム
- プラグイン開発ガイド
- サンプルプラグイン

---

### Phase 4: データ管理機能実装（2週間）

#### タスク 4.1: データベース設計
- [ ] テーブル設計
  - [ ] inspections テーブル
  - [ ] defects テーブル
  - [ ] reference_images テーブル
- [ ] インデックス設定
- [ ] マイグレーションスクリプト

#### タスク 4.2: DataManager 実装
- [ ] SQLite 統合 (SQLiteCpp)
- [ ] CRUD 操作実装
- [ ] 検索・フィルタリング機能
- [ ] CSV エクスポート

#### タスク 4.3: 統計機能実装
- [ ] 統計計算ロジック
- [ ] 日次/週次/月次集計
- [ ] 不良率計算
- [ ] 欠陥種類別分布

#### タスク 4.4: 履歴表示UI
- [ ] 検査履歴一覧表示
- [ ] 詳細表示
- [ ] 検索・フィルタリングUI

**成果物:**
- データ永続化機能
- 検査履歴管理
- 統計分析機能

---

### Phase 5: カメラ対応（2週間）

#### タスク 5.1: CameraController 実装
- [ ] OpenCV VideoCapture 統合
- [ ] カメラ列挙・選択
- [ ] フレーム取得
- [ ] 連続撮影モード

#### タスク 5.2: カメラパラメータ調整
- [ ] 解像度設定
- [ ] FPS 設定
- [ ] 露出調整
- [ ] ゲイン調整
- [ ] ホワイトバランス調整

#### タスク 5.3: リアルタイム検査
- [ ] ライブプレビュー
- [ ] 自動検査トリガー
- [ ] 結果オーバーレイ表示

#### タスク 5.4: カメラキャリブレーション
- [ ] チェスボードパターン検出
- [ ] カメラ行列計算
- [ ] 歪み補正

**成果物:**
- カメラからのリアルタイム検査
- カメラパラメータ調整機能
- キャリブレーション機能

---

### Phase 6: AI機能実装（3-4週間）

#### タスク 6.1: AI基盤構築
- [ ] ONNX Runtime 統合
- [ ] モデルローダー実装
- [ ] 推論エンジン実装

#### タスク 6.2: AI画像高画質化
- [ ] AIEnhancer クラス実装
- [ ] 超解像モデル統合 (ESRGAN, Real-ESRGAN等)
- [ ] デノイジングモデル統合
- [ ] 前処理・後処理パイプライン

#### タスク 6.3: AI欠陥検出
- [ ] AIDetector クラス実装
- [ ] 物体検出モデル統合 (YOLO, SSD等)
- [ ] セグメンテーションモデル統合 (U-Net等)
- [ ] 信頼度スコア処理

#### タスク 6.4: モデル管理
- [ ] モデルの動的読み込み
- [ ] 複数モデル切り替え
- [ ] モデル設定UI

#### タスク 6.5: 学習データ収集機能（オプション）
- [ ] アノテーション機能
- [ ] データセット管理
- [ ] エクスポート機能

**成果物:**
- AI画像高画質化機能
- AI欠陥検出機能
- 学習済みモデル統合

---

### Phase 7: UI改善（Qt版）（2-3週間）

#### タスク 7.1: Qt環境構築
- [ ] Qt 6 インストール・設定
- [ ] CMake Qt 統合
- [ ] UI デザイン方針決定

#### タスク 7.2: MainWindow 実装
- [ ] メニューバー
- [ ] ツールバー
- [ ] ステータスバー
- [ ] ドッキングウィンドウ

#### タスク 7.3: FilterPanel 実装
- [ ] フィルタリスト表示
- [ ] ドラッグ&ドロップでの順序変更
- [ ] パラメータ調整UI
- [ ] プリセット管理UI

#### タスク 7.4: ResultDisplay 実装
- [ ] 画像比較表示 (Before/After)
- [ ] ズーム・パン機能
- [ ] 欠陥ハイライト表示
- [ ] 詳細情報表示

#### タスク 7.5: 設定ダイアログ
- [ ] 全般設定
- [ ] カメラ設定
- [ ] 検査パラメータ設定
- [ ] AI モデル設定

#### タスク 7.6: グラフ表示
- [ ] 統計グラフ (QCustomPlot)
- [ ] 不良率推移
- [ ] 欠陥種類分布

**成果物:**
- プロフェッショナルなGUI
- 直感的な操作性
- データ可視化機能

---

### Phase 8: レポート機能（1-2週間）

#### タスク 8.1: レポート生成エンジン
- [ ] PDF ライブラリ統合 (QPrinter, libharu等)
- [ ] レポートテンプレート設計
- [ ] データ整形ロジック

#### タスク 8.2: レポート内容実装
- [ ] サマリー情報
- [ ] 不良品画像一覧
- [ ] 統計グラフ
- [ ] 詳細データテーブル

#### タスク 8.3: レポート設定
- [ ] テンプレート選択
- [ ] 出力項目設定
- [ ] 日付範囲指定

**成果物:**
- PDF レポート自動生成
- カスタマイズ可能なレポート

---

### Phase 9: テスト・最適化（2週間）

#### タスク 9.1: ユニットテスト
- [ ] Google Test 統合
- [ ] 各モジュールのテスト実装
- [ ] テストカバレッジ測定

#### タスク 9.2: 統合テスト
- [ ] エンドツーエンドテスト
- [ ] シナリオベーステスト
- [ ] パフォーマンステスト

#### タスク 9.3: 性能最適化
- [ ] プロファイリング
- [ ] ボトルネック特定
- [ ] 並列処理導入 (OpenMP, TBB)
- [ ] メモリ最適化

#### タスク 9.4: バグフィックス
- [ ] バグトラッキング
- [ ] 優先度付け
- [ ] 修正・検証

**成果物:**
- テストカバレッジ 70% 以上
- パフォーマンス要件達成
- 安定動作

---

### Phase 10: ドキュメント・リリース準備（1週間）

#### タスク 10.1: ドキュメント整備
- [ ] ユーザーマニュアル
- [ ] API ドキュメント (Doxygen)
- [ ] インストールガイド
- [ ] トラブルシューティングガイド

#### タスク 10.2: リリース準備
- [ ] インストーラー作成
- [ ] 依存ライブラリのパッケージング
- [ ] バージョニング
- [ ] リリースノート作成

#### タスク 10.3: デプロイメント
- [ ] テスト環境での検証
- [ ] ユーザー受け入れテスト (UAT)
- [ ] 本番環境デプロイ

**成果物:**
- 完全なドキュメントセット
- インストーラー
- リリース版

---

## 5. 技術スタック詳細

### 5.1 主要ライブラリ

| ライブラリ | バージョン | 用途 |
|-----------|-----------|------|
| OpenCV | 4.x | 画像処理・コンピュータビジョン |
| Qt | 6.x | GUI |
| nlohmann/json | 3.x | JSON パーサー |
| SQLiteCpp | 3.x | SQLite C++ ラッパー |
| ONNX Runtime | 1.x | AI モデル推論 |
| Google Test | 1.x | ユニットテスト |
| spdlog | 1.x | ロギング |

### 5.2 オプションライブラリ

| ライブラリ | 用途 |
|-----------|------|
| QCustomPlot | グラフ表示 |
| libharu | PDF 生成 |
| OpenMP | 並列処理 |
| Intel TBB | 並列処理 |

### 5.3 ビルドツール

- **CMake**: 3.15 以上
- **コンパイラ**:
  - GCC 7+
  - Clang 6+
  - MSVC 2019+

---

## 6. 開発ガイドライン

### 6.1 コーディング規約

#### C++ スタイル
- Google C++ Style Guide に準拠
- クラス名: PascalCase (例: `ImageProcessor`)
- 関数名: camelCase (例: `processImage()`)
- 変数名: snake_case (例: `image_data`)
- 定数名: UPPER_SNAKE_CASE (例: `MAX_IMAGE_SIZE`)
- メンバ変数: 末尾に `_` (例: `data_`)

#### ファイル構成
- ヘッダーファイル: `.hpp`
- ソースファイル: `.cpp`
- ヘッダーガード: `#pragma once`

#### コメント
```cpp
/**
 * @brief 画像にフィルタを適用する
 * @param input 入力画像
 * @return 処理済み画像
 * @throws std::invalid_argument 入力画像が空の場合
 */
cv::Mat applyFilter(const cv::Mat& input);
```

### 6.2 エラーハンドリング

```cpp
// 例外を使用
try {
    cv::Mat image = ImageIO::loadImage(path);
    // ...
} catch (const std::exception& e) {
    LOG_ERROR("Failed to load image: {}", e.what());
    return false;
}

// 戻り値で判定が必要な場合は std::optional 使用
std::optional<cv::Mat> loadImageSafe(const std::string& path);
```

### 6.3 ロギング

```cpp
#include "utils/logger.hpp"

LOG_DEBUG("Processing image: {}", filename);
LOG_INFO("Inspection completed: {} defects found", defects.size());
LOG_WARN("Low confidence detection: {:.2f}", confidence);
LOG_ERROR("Failed to open camera: {}", deviceId);
```

### 6.4 メモリ管理

- スマートポインタを優先使用
  - `std::unique_ptr`: 単独所有
  - `std::shared_ptr`: 共有所有
- `new`/`delete` の直接使用を避ける
- RAII パターンの活用

### 6.5 並行処理

```cpp
// OpenMP の使用例
#pragma omp parallel for
for (int i = 0; i < images.size(); ++i) {
    processedImages[i] = pipeline.process(images[i]);
}
```

---

## 7. テスト戦略

### 7.1 ユニットテスト

```cpp
// tests/unit/test_filters.cpp
#include <gtest/gtest.h>
#include "processing/filters/grayscale_filter.hpp"

TEST(GrayscaleFilterTest, BasicConversion) {
    cv::Mat input = cv::imread("test_data/color_image.jpg");
    GrayscaleFilter filter;
    cv::Mat output = filter.process(input);

    EXPECT_EQ(output.channels(), 1);
    EXPECT_EQ(output.size(), input.size());
}

TEST(GrayscaleFilterTest, EmptyInput) {
    cv::Mat input;
    GrayscaleFilter filter;
    EXPECT_THROW(filter.process(input), std::invalid_argument);
}
```

### 7.2 統合テスト

```cpp
// tests/integration/test_inspection.cpp
TEST(InspectionIntegrationTest, FullPipeline) {
    // 画像読み込み
    cv::Mat image = ImageIO::loadImage("test_data/defect_sample.jpg");

    // パイプライン構築
    Pipeline pipeline;
    pipeline.addFilter(std::make_unique<GrayscaleFilter>());
    pipeline.addFilter(std::make_unique<GaussianFilter>());
    pipeline.addFilter(std::make_unique<ThresholdFilter>());

    // 検査実行
    InspectionController controller;
    controller.setPipeline(std::move(pipeline));
    controller.addDetector(std::make_unique<TemplateMatcher>());

    auto result = controller.inspect(image);

    EXPECT_FALSE(result.isOK);
    EXPECT_GT(result.defects.size(), 0);
}
```

### 7.3 パフォーマンステスト

```cpp
TEST(PerformanceTest, ProcessingSpeed) {
    cv::Mat image = cv::imread("test_data/1920x1080.jpg");
    Pipeline pipeline;
    // ... setup

    auto start = std::chrono::high_resolution_clock::now();
    cv::Mat result = pipeline.process(image);
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    EXPECT_LT(duration.count(), 100); // 100ms 以下
}
```

---

## 8. リスク管理

### 8.1 技術的リスクと対策

| リスク | 影響度 | 確率 | 対策 |
|--------|--------|------|------|
| OpenCV バージョン互換性問題 | 高 | 中 | 特定バージョンに固定、CI/CD でテスト |
| AI モデルのパフォーマンス不足 | 高 | 中 | 軽量モデルの選定、モデル最適化 |
| カメラドライバ互換性 | 中 | 高 | 主要デバイスで事前検証 |
| 処理速度が要件未達 | 高 | 中 | 早期プロトタイプ、並列処理導入 |
| メモリリーク | 中 | 低 | Valgrind 等でチェック、スマートポインタ使用 |

### 8.2 スケジュールリスク

- **バッファ**: 各フェーズに10-20%のバッファを確保
- **並行作業**: 独立したタスクは並行実施
- **早期検証**: Phase 1 で技術検証を完了

---

## 9. 成功基準

### 9.1 機能要件
- ✅ すべての機能要件 (FR-01 ～ FR-08) が実装されている
- ✅ プラグインシステムが動作し、新規フィルタ追加が容易
- ✅ AI 機能が統合され、動作している

### 9.2 非機能要件
- ✅ 処理速度: 100ms/枚 以下
- ✅ 検出精度: 感度 90% 以上、特異度 95% 以上
- ✅ テストカバレッジ: 70% 以上
- ✅ メモリリークなし

### 9.3 品質基準
- ✅ コードレビュー実施
- ✅ ドキュメント完備
- ✅ ユーザー受け入れテスト合格

---

## 10. 次のステップ

### 10.1 即座に開始すべきタスク
1. **Phase 1 着手**: プロジェクト環境構築
2. **CMakeLists.txt 作成**: ビルドシステム確立
3. **ディレクトリ構造作成**: 標準構造に従う
4. **OpenCV インストール**: 開発環境準備

### 10.2 初回マイルストーン (2週間後)
- ビルド可能なプロジェクト
- 画像読み込み→グレースケール変換→表示のデモ
- 設定ファイル読み込み機能

### 10.3 継続的改善
- 定期的なコードレビュー
- パフォーマンスモニタリング
- ユーザーフィードバック収集

---

## 付録

### A. 参考資料

- [OpenCV Documentation](https://docs.opencv.org/)
- [Qt Documentation](https://doc.qt.io/)
- [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
- [CMake Tutorial](https://cmake.org/cmake/help/latest/guide/tutorial/index.html)

### B. サンプルコード

詳細なサンプルコードは `docs/examples/` に配置予定

### C. FAQ

**Q: なぜ Qt と OpenCV HighGUI の両方を使用するのか？**
A: Phase 1 では開発速度を優先して HighGUI を使用し、Phase 7 で本格的な GUI を Qt で実装します。

**Q: AI モデルの学習は含まれるか？**
A: Phase 6 では学習済みモデルの統合がメイン。学習機能はオプションです。

**Q: マルチプラットフォーム対応はどのフェーズで？**
A: Phase 1 から CMake でマルチプラットフォームを意識した設計とします。

---

## 変更履歴

| バージョン | 日付 | 変更内容 | 作成者 |
|----------|------|---------|--------|
| 1.0 | 2025-11-16 | 初版作成 | - |
