# 通信フォーマット設計書

## 概要

バックエンド（C++）とフロントエンド（React）間の通信フォーマットを定義します。

**重要な要件:**
- **外部機器起点の検査**: PLCやセンサーなどの外部機器からの撮影指示を受け、バックエンドが自動的に検査を実行
- **双方向通信必須**: バックエンドからフロントエンドへのプッシュ通知が必要

---

## システムフロー

```
┌──────────────┐
│ 外部機器     │ (PLCやセンサー)
│ (PLC/Sensor) │
└──────┬───────┘
       │ TCP/UDP/Serial/MQTT
       ↓
┌─────────────────────────────────┐
│  Backend (C++)                  │
│  ┌──────────────────────────┐  │
│  │ 外部トリガー受信         │  │ ← 撮影指示を受信
│  └───────────┬──────────────┘  │
│              ↓                  │
│  ┌──────────────────────────┐  │
│  │ カメラ制御・画像取得     │  │
│  └───────────┬──────────────┘  │
│              ↓                  │
│  ┌──────────────────────────┐  │
│  │ 検査実行                 │  │
│  └───────────┬──────────────┘  │
│              ↓                  │
│  ┌──────────────────────────┐  │
│  │ WebSocketでプッシュ通知  │  │ ← Reactに結果を送信
│  └──────────────────────────┘  │
└─────────────────────────────────┘
       │ WebSocket (双方向)
       ↓
┌─────────────────────────────────┐
│  React Frontend                 │
│  - 検査結果をリアルタイム表示  │
│  - 設定変更（REST API経由）    │
└─────────────────────────────────┘
```

---

## 通信プロトコルの選択

### 基本方針: REST + WebSocket（ハイブリッド）

#### REST API
**用途:**
- 設定の取得・変更
- 履歴データの取得
- 統計情報の取得
- 良品画像の登録

**理由:**
- ✅ 標準的で広く使われている
- ✅ デバッグが容易（ブラウザのDevToolsで確認可能）
- ✅ React側での扱いが簡単
- ✅ OpenAPI/Swaggerで文書化可能
- ✅ ツールが豊富（Postman等でテスト可能）

#### WebSocket（重要）★
**用途:**
- **検査結果のプッシュ通知**（外部機器起点）★最重要
- リアルタイムプレビュー
- 処理進捗の通知
- ライブカメラフィード

**理由:**
- ✅ **双方向通信対応**: Backend → React のプッシュ通知が可能
- ✅ **外部機器起点に対応**: Backendが外部トリガーを受けてReactに通知
- ✅ リアルタイム性が高い
- ✅ ブラウザネイティブ対応
- ✅ 接続を維持して低遅延通信

---

## データフォーマット: JSON

### 選択理由

| フォーマット | メリット | デメリット | 採用 |
|------------|---------|-----------|------|
| JSON | 読みやすい、標準的、デバッグ容易 | やや冗長 | ✅ 採用 |
| Protocol Buffers | 高速、型安全 | バイナリで読みにくい | ❌ |
| MessagePack | JSONより小さい | JSONほど標準的でない | ❌ |
| BSON | MongoDBで使用 | 特殊用途向け | ❌ |

### JSON拡張: 画像データの扱い

画像データは以下の方法で扱います：

1. **ファイルパスを送信**（推奨）
   ```json
   {
     "image_path": "/path/to/image.jpg"
   }
   ```

2. **Base64エンコード**（小さい画像のみ）
   ```json
   {
     "image_data": "data:image/jpeg;base64,/9j/4AAQSkZJRg..."
   }
   ```

3. **マルチパートフォーム**（アップロード時）
   ```
   Content-Type: multipart/form-data
   ```

---

## API設計（RESTful）

### エンドポイント一覧

| メソッド | エンドポイント | 説明 |
|---------|---------------|------|
| POST | `/api/v1/inspect` | 画像検査を実行 |
| GET | `/api/v1/inspect/{id}` | 検査結果を取得 |
| POST | `/api/v1/images/upload` | 画像をアップロード |
| GET | `/api/v1/pipeline` | パイプライン設定を取得 |
| PUT | `/api/v1/pipeline` | パイプライン設定を更新 |
| GET | `/api/v1/pipeline/presets` | プリセット一覧を取得 |
| POST | `/api/v1/pipeline/presets` | プリセットを保存 |
| GET | `/api/v1/filters` | 利用可能なフィルタ一覧 |
| GET | `/api/v1/detectors` | 利用可能な検出器一覧 |
| GET | `/api/v1/history` | 検査履歴を取得 |
| GET | `/api/v1/statistics` | 統計情報を取得 |
| POST | `/api/v1/reference` | 良品画像を登録 |
| GET | `/api/v1/camera/list` | カメラデバイス一覧 |
| POST | `/api/v1/camera/start` | カメラを起動 |
| POST | `/api/v1/camera/stop` | カメラを停止 |

---

## リクエスト/レスポンス設計

### 基本構造

すべてのレスポンスは以下の共通構造を持ちます：

```json
{
  "success": true,
  "data": { /* 実際のデータ */ },
  "error": null,
  "timestamp": "2025-11-16T10:30:00Z",
  "request_id": "uuid-1234-5678"
}
```

エラー時：

```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "INVALID_IMAGE",
    "message": "画像ファイルが見つかりません",
    "details": {
      "path": "/invalid/path.jpg"
    }
  },
  "timestamp": "2025-11-16T10:30:00Z",
  "request_id": "uuid-1234-5678"
}
```

---

## API詳細仕様

### 1. 画像検査API

#### POST /api/v1/inspect

**リクエスト:**

```json
{
  "image_path": "/path/to/image.jpg",
  "pipeline_preset": "default",
  "detectors": ["template_matching", "ai_detector"],
  "options": {
    "save_result": true,
    "return_processed_image": true
  }
}
```

または画像データを直接送信：

```json
{
  "image_data": "base64-encoded-image-data",
  "image_format": "jpeg",
  "pipeline_preset": "default",
  "detectors": ["template_matching"]
}
```

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "inspection_id": "insp-1234",
    "result": {
      "is_ok": false,
      "judgment": "NG",
      "defect_count": 2,
      "confidence": 0.95,
      "processing_time_ms": 87
    },
    "defects": [
      {
        "id": 1,
        "type": "scratch",
        "type_code": 0,
        "confidence": 0.98,
        "bbox": {
          "x": 100,
          "y": 150,
          "width": 50,
          "height": 30
        },
        "area": 1500,
        "detected_by": "ai_detector"
      },
      {
        "id": 2,
        "type": "stain",
        "type_code": 1,
        "confidence": 0.92,
        "bbox": {
          "x": 300,
          "y": 200,
          "width": 40,
          "height": 40
        },
        "area": 1600,
        "detected_by": "template_matching"
      }
    ],
    "processed_image": {
      "url": "/api/v1/images/insp-1234/processed.jpg",
      "base64": null  // return_processed_image=false の場合
    },
    "pipeline_used": [
      {"name": "grayscale", "params": {}},
      {"name": "gaussian_blur", "params": {"kernel_size": 5, "sigma": 1.0}},
      {"name": "threshold", "params": {"threshold": 128}}
    ]
  },
  "error": null,
  "timestamp": "2025-11-16T10:30:00Z",
  "request_id": "req-5678"
}
```

---

### 2. パイプライン設定API

#### GET /api/v1/pipeline

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "current_preset": "custom",
    "filters": [
      {
        "id": "filter-1",
        "name": "grayscale",
        "display_name": "グレースケール変換",
        "enabled": true,
        "parameters": {}
      },
      {
        "id": "filter-2",
        "name": "gaussian_blur",
        "display_name": "ガウシアンブラー",
        "enabled": true,
        "parameters": {
          "kernel_size": {
            "type": "integer",
            "value": 5,
            "min": 1,
            "max": 31,
            "step": 2
          },
          "sigma": {
            "type": "float",
            "value": 1.0,
            "min": 0.1,
            "max": 10.0,
            "step": 0.1
          }
        }
      },
      {
        "id": "filter-3",
        "name": "ai_enhancer",
        "display_name": "AI画質向上",
        "enabled": false,
        "parameters": {
          "model": {
            "type": "enum",
            "value": "esrgan",
            "options": ["esrgan", "denoise", "sharpen"]
          }
        }
      }
    ]
  }
}
```

#### PUT /api/v1/pipeline

**リクエスト:**

```json
{
  "filters": [
    {
      "name": "grayscale",
      "enabled": true,
      "parameters": {}
    },
    {
      "name": "gaussian_blur",
      "enabled": true,
      "parameters": {
        "kernel_size": 7,
        "sigma": 1.5
      }
    }
  ]
}
```

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "message": "Pipeline updated successfully",
    "filter_count": 2
  }
}
```

---

### 3. フィルタ・検出器情報API

#### GET /api/v1/filters

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "filters": [
      {
        "name": "grayscale",
        "display_name": "グレースケール変換",
        "description": "カラー画像をグレースケールに変換します",
        "category": "basic",
        "parameters": {}
      },
      {
        "name": "gaussian_blur",
        "display_name": "ガウシアンブラー",
        "description": "ガウシアンフィルタでノイズを除去します",
        "category": "noise_reduction",
        "parameters": {
          "kernel_size": {
            "type": "integer",
            "default": 5,
            "min": 1,
            "max": 31,
            "step": 2,
            "description": "カーネルサイズ（奇数）"
          },
          "sigma": {
            "type": "float",
            "default": 1.0,
            "min": 0.1,
            "max": 10.0,
            "step": 0.1,
            "description": "標準偏差"
          }
        }
      },
      {
        "name": "ai_enhancer",
        "display_name": "AI画質向上",
        "description": "AIモデルで画像を高画質化します",
        "category": "ai",
        "parameters": {
          "model": {
            "type": "enum",
            "default": "esrgan",
            "options": [
              {"value": "esrgan", "label": "超解像(ESRGAN)"},
              {"value": "denoise", "label": "ノイズ除去"},
              {"value": "sharpen", "label": "シャープ化"}
            ],
            "description": "使用するAIモデル"
          }
        }
      }
    ]
  }
}
```

#### GET /api/v1/detectors

同様の構造で検出器情報を返します。

---

### 4. 検査履歴API

#### GET /api/v1/history?from=2025-11-01&to=2025-11-16&limit=50&offset=0

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "total": 150,
    "limit": 50,
    "offset": 0,
    "items": [
      {
        "id": "insp-1234",
        "timestamp": "2025-11-16T10:30:00Z",
        "image_path": "/data/images/2025-11-16/sample.jpg",
        "thumbnail_url": "/api/v1/images/insp-1234/thumbnail.jpg",
        "result": "NG",
        "defect_count": 2,
        "processing_time_ms": 87
      },
      {
        "id": "insp-1233",
        "timestamp": "2025-11-16T10:25:00Z",
        "image_path": "/data/images/2025-11-16/sample2.jpg",
        "thumbnail_url": "/api/v1/images/insp-1233/thumbnail.jpg",
        "result": "OK",
        "defect_count": 0,
        "processing_time_ms": 65
      }
    ]
  }
}
```

---

### 5. 統計情報API

#### GET /api/v1/statistics?from=2025-11-01&to=2025-11-16&group_by=day

**レスポンス:**

```json
{
  "success": true,
  "data": {
    "summary": {
      "total_inspections": 1500,
      "ok_count": 1350,
      "ng_count": 150,
      "defect_rate": 0.10,
      "average_processing_time_ms": 85
    },
    "by_date": [
      {
        "date": "2025-11-16",
        "total": 100,
        "ok": 90,
        "ng": 10,
        "defect_rate": 0.10
      },
      {
        "date": "2025-11-15",
        "total": 120,
        "ok": 108,
        "ng": 12,
        "defect_rate": 0.10
      }
    ],
    "by_defect_type": [
      {
        "type": "scratch",
        "type_code": 0,
        "count": 80,
        "percentage": 0.53
      },
      {
        "type": "stain",
        "type_code": 1,
        "count": 50,
        "percentage": 0.33
      },
      {
        "type": "discoloration",
        "type_code": 2,
        "count": 20,
        "percentage": 0.13
      }
    ]
  }
}
```

---

## WebSocket通信（双方向・リアルタイム機能）

### 接続

```
ws://localhost:8080/ws/inspection
```

### メッセージフォーマット

すべてのメッセージはJSON形式：

```json
{
  "type": "message_type",
  "data": { /* データ */ },
  "timestamp": "2025-11-16T10:30:00Z"
}
```

### イベント種類

#### 1. 検査完了通知（外部機器起点）★最重要

**Server → Client:**

外部機器からの撮影指示を受けて、バックエンドが自動的に検査を実行した後、結果をプッシュ通知します。

```json
{
  "type": "inspection_complete",
  "data": {
    "inspection_id": "insp-12345",
    "trigger_source": "plc-line-01",
    "trigger_type": "external",
    "timestamp": "2025-11-16T10:30:00.123Z",
    "result": {
      "judgment": "NG",
      "is_ok": false,
      "defect_count": 2,
      "confidence": 0.95,
      "processing_time_ms": 87
    },
    "defects": [
      {
        "id": 1,
        "type": "scratch",
        "confidence": 0.98,
        "bbox": { "x": 100, "y": 150, "width": 50, "height": 30 }
      },
      {
        "id": 2,
        "type": "stain",
        "confidence": 0.92,
        "bbox": { "x": 300, "y": 200, "width": 40, "height": 40 }
      }
    ],
    "image_url": "/api/v1/images/insp-12345/result.jpg",
    "thumbnail_url": "/api/v1/images/insp-12345/thumbnail.jpg"
  }
}
```

#### 2. カメラフレーム配信

**Server → Client:**

```json
{
  "type": "camera_frame",
  "data": {
    "frame_id": 12345,
    "image_data": "base64-encoded-jpeg",
    "timestamp": "2025-11-16T10:30:00.123Z"
  }
}
```

#### 3. 処理進捗通知

**Server → Client:**

```json
{
  "type": "inspection_progress",
  "data": {
    "inspection_id": "insp-5678",
    "stage": "filtering",
    "stage_name": "フィルタ処理中",
    "progress": 0.45,
    "current_filter": "gaussian_blur"
  }
}
```

#### 4. 外部機器ステータス通知

**Server → Client:**

外部機器の接続状態や異常を通知します。

```json
{
  "type": "external_device_status",
  "data": {
    "device_id": "plc-line-01",
    "status": "connected",
    "last_trigger": "2025-11-16T10:30:00Z",
    "error": null
  }
}
```

#### 5. クライアントからのコマンド（双方向）

**Client → Server:**

```json
{
  "type": "command",
  "data": {
    "command": "start_camera",
    "params": {
      "device_id": 0,
      "resolution": "1920x1080"
    }
  }
}
```

**Client → Server: 手動検査トリガー**

```json
{
  "type": "command",
  "data": {
    "command": "manual_inspect",
    "params": {
      "image_path": "/path/to/image.jpg"
    }
  }
}
```

---

## エラーコード一覧

| コード | 説明 |
|-------|------|
| `SUCCESS` | 成功 |
| `INVALID_REQUEST` | リクエストが不正 |
| `INVALID_IMAGE` | 画像が不正または存在しない |
| `PROCESSING_FAILED` | 処理中にエラーが発生 |
| `PIPELINE_ERROR` | パイプライン設定エラー |
| `MODEL_LOAD_ERROR` | AIモデルの読み込みエラー |
| `CAMERA_ERROR` | カメラアクセスエラー |
| `DATABASE_ERROR` | データベースエラー |
| `NOT_FOUND` | リソースが見つからない |
| `UNAUTHORIZED` | 認証エラー（将来の拡張） |
| `INTERNAL_ERROR` | 内部エラー |

---

## 外部機器インターフェース

### 外部機器からのトリガー受信

外部機器（PLC、センサー等）からの撮影指示を受け取るためのインターフェース。

#### サポートするプロトコル

| プロトコル | 用途 | 実装優先度 |
|-----------|------|-----------|
| TCP Socket | PLC、産業用機器 | 高 |
| UDP | 高速トリガー | 中 |
| Serial (RS-232/485) | レガシー機器 | 中 |
| MQTT | IoTデバイス | 低 |
| Modbus TCP | 産業用PLC | 低 |

#### トリガーメッセージフォーマット

**TCP/UDPの場合（JSON）:**

```json
{
  "command": "trigger",
  "device_id": "plc-line-01",
  "timestamp": "2025-11-16T10:30:00Z",
  "params": {
    "product_id": "PROD-12345",
    "line_number": 1
  }
}
```

**シリアル通信の場合（テキスト）:**

```
TRIGGER,plc-line-01,PROD-12345\n
```

---

## C++実装例

### 外部トリガーハンドラー

```cpp
// external_trigger_handler.hpp
#include <boost/asio.hpp>
#include <nlohmann/json.hpp>

using json = nlohmann::json;
using boost::asio::ip::tcp;

struct TriggerEvent {
    std::string deviceId;
    std::string productId;
    int lineNumber;
    std::chrono::system_clock::time_point timestamp;
};

class ExternalTriggerHandler {
public:
    using TriggerCallback = std::function<void(const TriggerEvent&)>;

    ExternalTriggerHandler(boost::asio::io_context& io_context)
        : acceptor_(io_context, tcp::endpoint(tcp::v4(), 8888)) {}

    void startListening(TriggerCallback callback) {
        callback_ = callback;
        startAccept();
    }

private:
    void startAccept() {
        auto socket = std::make_shared<tcp::socket>(acceptor_.get_executor());

        acceptor_.async_accept(*socket, [this, socket](boost::system::error_code ec) {
            if (!ec) {
                handleConnection(socket);
            }
            startAccept();
        });
    }

    void handleConnection(std::shared_ptr<tcp::socket> socket) {
        auto buffer = std::make_shared<boost::asio::streambuf>();

        boost::asio::async_read_until(*socket, *buffer, '\n',
            [this, socket, buffer](boost::system::error_code ec, std::size_t) {
                if (!ec) {
                    std::istream is(buffer.get());
                    std::string message;
                    std::getline(is, message);

                    processMessage(message);
                }
            });
    }

    void processMessage(const std::string& message) {
        try {
            auto data = json::parse(message);

            if (data["command"] == "trigger") {
                TriggerEvent event;
                event.deviceId = data["device_id"];
                event.productId = data.value("params", json::object())
                                      .value("product_id", "");
                event.lineNumber = data.value("params", json::object())
                                       .value("line_number", 0);
                event.timestamp = std::chrono::system_clock::now();

                if (callback_) {
                    callback_(event);
                }
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Failed to parse trigger message: {}", e.what());
        }
    }

    tcp::acceptor acceptor_;
    TriggerCallback callback_;
};
```

### 統合サーバー実装

```cpp
// inspection_server.cpp
#include "external_trigger_handler.hpp"
#include "inspection_controller.hpp"
#include "camera_controller.hpp"
#include "crow.h"

class InspectionServer {
public:
    InspectionServer()
        : ioContext_(),
          externalTrigger_(ioContext_),
          wsClients_() {}

    void run() {
        // 外部トリガーハンドラー起動
        externalTrigger_.startListening([this](const TriggerEvent& event) {
            handleExternalTrigger(event);
        });

        // WebSocketサーバー起動
        setupWebSocket();

        // REST APIサーバー起動
        setupRestAPI();

        // Boost.Asioイベントループ（外部機器用）
        std::thread([this]() { ioContext_.run(); }).detach();

        // CrowサーバーStart（ブロッキング）
        app_.port(8080).multithreaded().run();
    }

private:
    void handleExternalTrigger(const TriggerEvent& event) {
        LOG_INFO("External trigger received from: {}", event.deviceId);

        try {
            // 1. カメラから画像取得
            cv::Mat image = cameraController_.captureFrame();
            if (image.empty()) {
                LOG_ERROR("Failed to capture image");
                return;
            }

            // 2. 検査実行
            auto result = inspectionController_.inspect(image);

            // 3. データベースに保存
            InspectionRecord record;
            record.timestamp = getCurrentTimestamp();
            record.triggerSource = event.deviceId;
            record.productId = event.productId;
            record.result = result.isOK;
            record.defects = result.defects;
            dataManager_.saveInspectionResult(record);

            // 4. WebSocketでReactクライアントに通知（プッシュ）
            json notification = {
                {"type", "inspection_complete"},
                {"data", {
                    {"inspection_id", record.id},
                    {"trigger_source", event.deviceId},
                    {"trigger_type", "external"},
                    {"product_id", event.productId},
                    {"timestamp", record.timestamp},
                    {"result", {
                        {"judgment", result.isOK ? "OK" : "NG"},
                        {"is_ok", result.isOK},
                        {"defect_count", result.defects.size()},
                        {"confidence", result.confidence},
                        {"processing_time_ms", result.processingTime}
                    }},
                    {"defects", serializeDefects(result.defects)},
                    {"image_url", getImageUrl(record.id)},
                    {"thumbnail_url", getThumbnailUrl(record.id)}
                }}
            };

            broadcastWebSocket(notification.dump());

            LOG_INFO("Inspection completed: {} (defects: {})",
                     result.isOK ? "OK" : "NG",
                     result.defects.size());

        } catch (const std::exception& e) {
            LOG_ERROR("Inspection failed: {}", e.what());
        }
    }

    void setupWebSocket() {
        CROW_WEBSOCKET_ROUTE(app_, "/ws/inspection")
            .onopen([this](crow::websocket::connection& conn) {
                std::lock_guard<std::mutex> lock(wsMutex_);
                wsClients_.insert(&conn);
                LOG_INFO("WebSocket client connected. Total: {}", wsClients_.size());

                // 接続時に外部機器のステータスを送信
                sendDeviceStatus(conn);
            })
            .onclose([this](crow::websocket::connection& conn, const std::string&) {
                std::lock_guard<std::mutex> lock(wsMutex_);
                wsClients_.erase(&conn);
                LOG_INFO("WebSocket client disconnected. Total: {}", wsClients_.size());
            })
            .onmessage([this](crow::websocket::connection& conn,
                             const std::string& data, bool) {
                handleClientMessage(conn, data);
            });
    }

    void broadcastWebSocket(const std::string& message) {
        std::lock_guard<std::mutex> lock(wsMutex_);
        for (auto* client : wsClients_) {
            client->send_text(message);
        }
    }

    void handleClientMessage(crow::websocket::connection& conn,
                            const std::string& data) {
        try {
            auto message = json::parse(data);
            std::string type = message["type"];

            if (type == "command") {
                std::string command = message["data"]["command"];

                if (command == "manual_inspect") {
                    // 手動検査トリガー
                    std::string imagePath = message["data"]["params"]["image_path"];
                    // 処理...
                }
            }
        } catch (const std::exception& e) {
            LOG_ERROR("Failed to handle client message: {}", e.what());
        }
    }

    boost::asio::io_context ioContext_;
    ExternalTriggerHandler externalTrigger_;
    InspectionController inspectionController_;
    CameraController cameraController_;
    DataManager dataManager_;
    crow::SimpleApp app_;
    std::set<crow::websocket::connection*> wsClients_;
    std::mutex wsMutex_;
};
```

### JSON処理（nlohmann/json使用）

```cpp
#include <nlohmann/json.hpp>
using json = nlohmann::json;

class InspectionAPI {
public:
    std::string inspectImage(const std::string& requestJson) {
        json response;

        try {
            // リクエストパース
            auto request = json::parse(requestJson);
            std::string imagePath = request["image_path"];

            // バリデーション
            if (!std::filesystem::exists(imagePath)) {
                return createErrorResponse("INVALID_IMAGE",
                    "Image file not found");
            }

            // ビジネスロジック実行
            cv::Mat image = ImageIO::loadImage(imagePath);
            auto result = inspectionController_->inspect(image);

            // レスポンス構築
            response["success"] = true;
            response["data"] = {
                {"inspection_id", generateUUID()},
                {"result", {
                    {"is_ok", result.isOK},
                    {"judgment", result.isOK ? "OK" : "NG"},
                    {"defect_count", result.defects.size()},
                    {"processing_time_ms", result.processingTime}
                }},
                {"defects", json::array()}
            };

            // 欠陥情報
            for (const auto& defect : result.defects) {
                response["data"]["defects"].push_back({
                    {"type", defectTypeToString(defect.type)},
                    {"type_code", static_cast<int>(defect.type)},
                    {"confidence", defect.confidence},
                    {"bbox", {
                        {"x", defect.boundingBox.x},
                        {"y", defect.boundingBox.y},
                        {"width", defect.boundingBox.width},
                        {"height", defect.boundingBox.height}
                    }}
                });
            }

        } catch (const std::exception& e) {
            return createErrorResponse("PROCESSING_FAILED", e.what());
        }

        response["error"] = nullptr;
        response["timestamp"] = getCurrentTimestamp();

        return response.dump();
    }

private:
    std::string createErrorResponse(const std::string& code,
                                    const std::string& message) {
        json response = {
            {"success", false},
            {"data", nullptr},
            {"error", {
                {"code", code},
                {"message", message}
            }},
            {"timestamp", getCurrentTimestamp()}
        };
        return response.dump();
    }

    std::string getCurrentTimestamp() {
        auto now = std::chrono::system_clock::now();
        auto time = std::chrono::system_clock::to_time_t(now);
        std::stringstream ss;
        ss << std::put_time(std::gmtime(&time), "%Y-%m-%dT%H:%M:%SZ");
        return ss.str();
    }

    std::string defectTypeToString(DefectType type) {
        switch (type) {
            case DefectType::SCRATCH: return "scratch";
            case DefectType::STAIN: return "stain";
            case DefectType::DISCOLORATION: return "discoloration";
            case DefectType::DEFORMATION: return "deformation";
            default: return "unknown";
        }
    }
};
```

---

## React実装例

### WebSocket Hook（外部機器起点対応）

```typescript
// hooks/useInspectionWebSocket.ts
import { useEffect, useState, useCallback } from 'react';

interface InspectionResult {
  inspection_id: string;
  trigger_source: string;
  trigger_type: 'external' | 'manual';
  product_id?: string;
  timestamp: string;
  result: {
    judgment: 'OK' | 'NG';
    is_ok: boolean;
    defect_count: number;
    confidence: number;
    processing_time_ms: number;
  };
  defects: Array<any>;
  image_url: string;
  thumbnail_url: string;
}

export function useInspectionWebSocket() {
  const [connected, setConnected] = useState(false);
  const [latestResult, setLatestResult] = useState<InspectionResult | null>(null);
  const [history, setHistory] = useState<InspectionResult[]>([]);
  const [ws, setWs] = useState<WebSocket | null>(null);

  useEffect(() => {
    const socket = new WebSocket('ws://localhost:8080/ws/inspection');

    socket.onopen = () => {
      console.log('WebSocket connected');
      setConnected(true);
    };

    socket.onmessage = (event) => {
      const message = JSON.parse(event.data);

      switch (message.type) {
        case 'inspection_complete':
          // 外部機器からのトリガーで検査完了
          const result: InspectionResult = message.data;
          setLatestResult(result);
          setHistory(prev => [result, ...prev.slice(0, 99)]); // 最新100件

          // 不良品の場合は音と通知
          if (result.result.judgment === 'NG') {
            playNGSound();
            showNotification(
              `不良品検出！`,
              `欠陥数: ${result.result.defect_count}`,
              'error'
            );
          } else {
            playOKSound();
          }
          break;

        case 'inspection_progress':
          // 進捗表示
          console.log('Progress:', message.data);
          break;

        case 'external_device_status':
          // 外部機器ステータス
          console.log('Device status:', message.data);
          break;
      }
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      setConnected(false);
    };

    socket.onclose = () => {
      console.log('WebSocket disconnected');
      setConnected(false);

      // 自動再接続（5秒後）
      setTimeout(() => {
        console.log('Reconnecting...');
        window.location.reload(); // 簡易的な再接続
      }, 5000);
    };

    setWs(socket);

    return () => {
      socket.close();
    };
  }, []);

  const sendCommand = useCallback((command: string, params: any) => {
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({
        type: 'command',
        data: { command, params }
      }));
    }
  }, [ws]);

  return {
    connected,
    latestResult,
    history,
    sendCommand
  };
}

function playOKSound() {
  const audio = new Audio('/sounds/ok.mp3');
  audio.play();
}

function playNGSound() {
  const audio = new Audio('/sounds/ng.mp3');
  audio.play();
}

function showNotification(title: string, message: string, type: 'error' | 'success') {
  if ('Notification' in window && Notification.permission === 'granted') {
    new Notification(title, { body: message });
  }
}
```

### リアルタイムモニター画面

```typescript
// components/InspectionMonitor.tsx
import React from 'react';
import { useInspectionWebSocket } from '../hooks/useInspectionWebSocket';

export function InspectionMonitor() {
  const { connected, latestResult, history } = useInspectionWebSocket();

  return (
    <div className="inspection-monitor">
      <header>
        <h1>外観検査モニター</h1>
        <div className={`status ${connected ? 'connected' : 'disconnected'}`}>
          {connected ? '接続中' : '切断'}
        </div>
      </header>

      {/* 最新結果 */}
      {latestResult && (
        <section className="latest-result">
          <h2>最新検査結果</h2>
          <div className={`result-card ${latestResult.result.judgment.toLowerCase()}`}>
            <div className="result-header">
              <span className="judgment">{latestResult.result.judgment}</span>
              <span className="timestamp">{new Date(latestResult.timestamp).toLocaleString()}</span>
            </div>

            <div className="result-body">
              <img
                src={latestResult.image_url}
                alt="検査画像"
                className="result-image"
              />

              <div className="result-info">
                <p>トリガー元: {latestResult.trigger_source}</p>
                <p>欠陥数: {latestResult.result.defect_count}</p>
                <p>信頼度: {(latestResult.result.confidence * 100).toFixed(1)}%</p>
                <p>処理時間: {latestResult.result.processing_time_ms}ms</p>

                {latestResult.result.defect_count > 0 && (
                  <div className="defects">
                    <h3>検出された欠陥:</h3>
                    <ul>
                      {latestResult.defects.map((defect, i) => (
                        <li key={i}>
                          {defect.type} (信頼度: {(defect.confidence * 100).toFixed(1)}%)
                        </li>
                      ))}
                    </ul>
                  </div>
                )}
              </div>
            </div>
          </div>
        </section>
      )}

      {/* 検査履歴 */}
      <section className="history">
        <h2>検査履歴</h2>
        <table>
          <thead>
            <tr>
              <th>時刻</th>
              <th>トリガー元</th>
              <th>判定</th>
              <th>欠陥数</th>
              <th>処理時間</th>
            </tr>
          </thead>
          <tbody>
            {history.map((item) => (
              <tr key={item.inspection_id} className={item.result.judgment.toLowerCase()}>
                <td>{new Date(item.timestamp).toLocaleTimeString()}</td>
                <td>{item.trigger_source}</td>
                <td>{item.result.judgment}</td>
                <td>{item.result.defect_count}</td>
                <td>{item.result.processing_time_ms}ms</td>
              </tr>
            ))}
          </tbody>
        </table>
      </section>
    </div>
  );
}
```

### API Client

```typescript
// api/client.ts
const API_BASE_URL = 'http://localhost:8080/api/v1';

interface APIResponse<T> {
  success: boolean;
  data: T | null;
  error: {
    code: string;
    message: string;
    details?: any;
  } | null;
  timestamp: string;
  request_id?: string;
}

interface InspectionRequest {
  image_path: string;
  pipeline_preset?: string;
  detectors?: string[];
  options?: {
    save_result?: boolean;
    return_processed_image?: boolean;
  };
}

interface InspectionResult {
  inspection_id: string;
  result: {
    is_ok: boolean;
    judgment: 'OK' | 'NG';
    defect_count: number;
    confidence: number;
    processing_time_ms: number;
  };
  defects: Array<{
    id: number;
    type: string;
    confidence: number;
    bbox: { x: number; y: number; width: number; height: number };
  }>;
}

export class InspectionAPIClient {
  async inspectImage(request: InspectionRequest): Promise<InspectionResult> {
    const response = await fetch(`${API_BASE_URL}/inspect`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(request)
    });

    const apiResponse: APIResponse<InspectionResult> = await response.json();

    if (!apiResponse.success || !apiResponse.data) {
      throw new Error(apiResponse.error?.message || 'Unknown error');
    }

    return apiResponse.data;
  }

  async getPipeline() {
    const response = await fetch(`${API_BASE_URL}/pipeline`);
    const apiResponse = await response.json();

    if (!apiResponse.success) {
      throw new Error(apiResponse.error?.message);
    }

    return apiResponse.data;
  }

  async updatePipeline(filters: any[]) {
    const response = await fetch(`${API_BASE_URL}/pipeline`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filters })
    });

    const apiResponse = await response.json();

    if (!apiResponse.success) {
      throw new Error(apiResponse.error?.message);
    }

    return apiResponse.data;
  }
}
```

### React Hook

```typescript
// hooks/useInspection.ts
import { useState } from 'react';
import { InspectionAPIClient } from '../api/client';

export function useInspection() {
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState(null);
  const [error, setError] = useState(null);

  const client = new InspectionAPIClient();

  const inspectImage = async (imagePath: string) => {
    setLoading(true);
    setError(null);

    try {
      const data = await client.inspectImage({ image_path: imagePath });
      setResult(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  return { inspectImage, loading, result, error };
}
```

---

## OpenAPI仕様（抜粋）

```yaml
openapi: 3.0.0
info:
  title: Inspection API
  version: 1.0.0
  description: 外観検査システムAPI

servers:
  - url: http://localhost:8080/api/v1

paths:
  /inspect:
    post:
      summary: 画像検査を実行
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/InspectionRequest'
      responses:
        '200':
          description: 検査成功
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/InspectionResponse'

components:
  schemas:
    InspectionRequest:
      type: object
      required:
        - image_path
      properties:
        image_path:
          type: string
        pipeline_preset:
          type: string
          default: "default"
        detectors:
          type: array
          items:
            type: string

    InspectionResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          type: object
          properties:
            inspection_id:
              type: string
            result:
              type: object
              properties:
                is_ok:
                  type: boolean
                defect_count:
                  type: integer
```

---

## まとめ

### 推奨構成

| 通信路 | プロトコル | 用途 |
|-------|----------|------|
| 外部機器 → Backend | TCP/UDP/Serial/MQTT | 撮影トリガー |
| Backend → React | **WebSocket** | 検査結果のプッシュ通知★ |
| React → Backend | **REST API** | 設定変更、履歴取得 |
| Backend ↔ React | **WebSocket** | カメラフィード、進捗通知 |

### システムフロー（完全版）

```
外部機器 → Backend: 撮影トリガー (TCP/UDP)
  ↓
Backend: カメラ制御・画像取得
  ↓
Backend: 検査実行
  ↓
Backend → React: 結果通知 (WebSocket Push)
  ↓
React: リアルタイム表示・アラート
```

### メリット

- ✅ **外部機器起点に対応**: バックエンドが自動的に検査を実行
- ✅ **双方向通信**: WebSocketでBackend→Reactのプッシュ通知
- ✅ フロントエンドとバックエンドの完全な分離
- ✅ 標準的で理解しやすい
- ✅ デバッグ・テストが容易
- ✅ ドキュメント化しやすい（OpenAPI）
- ✅ React移行がスムーズ

### 実装優先度

1. **Phase 1**: REST API（設定・履歴取得）
2. **Phase 2**: WebSocket（検査結果プッシュ通知）★重要
3. **Phase 3**: 外部機器インターフェース（TCP Socket）
4. **Phase 4**: 追加プロトコル（UDP、Serial等）

---

**最終更新**: 2025-11-16
